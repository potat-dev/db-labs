# Ответы на билеты

## 1. Назначение, компоненты базы, банка данных, СУБД. Роль и место баз данных в современном мире.

### Ответ:

1. **База данных (БД)** - это структурированная совокупность данных, организованная по определенным правилам, обеспечивающим их хранение,  извлечение,  модификацию  и поиск. Представьте себе огромную библиотеку с книгами,  расставленными по темам и авторам - это и есть база данных,  где каждая книга - это отдельный элемент данных.

2. **Компоненты базы данных:**

    * **Данные:** Основной компонент,  представляющий собой  информацию, хранящуюся в базе данных.  Это могут быть тексты,  числа,  изображения,  файлы и т.д. В нашем примере с библиотекой - это сами книги.
    * **Метаданные:** Данные о данных.  Описывают структуру,  формат  и другие характеристики данных.  В библиотеке  это каталог,  где указаны  автор,  название,  год издания  каждой книги.
    * **Язык запросов:** Позволяет  пользователям  взаимодействовать с базой данных,  извлекать  и  модифицировать  данные.  В  библиотеке  это  поиск  по  каталогу.

3. **Банк данных (БнД)** - это более широкое понятие,  включающее в себя не только базу данных,  но и:
    * **Системы управления базами данных (СУБД).**
    * **Комплекс программно-технических средств**.
    * **Информационные ресурсы**.

    БнД ориентирован на централизованное накопление и коллективное использование данных.

4. **Система управления базами данных (СУБД)** - это комплекс программных средств,  обеспечивающих создание,  ведение и использование базы данных.  СУБД  позволяет  пользователям  и  приложениям  взаимодействовать с базой данных,  выполнять  запросы,  изменять  данные  и  управлять  доступом.

    **Основные функции СУБД:**
    * **Определение данных:**  Описание  структуры  и  типов  данных.
    * **Манипулирование данными:**  Добавление,  изменение,  удаление  и  поиск  данных.
    * **Управление доступом:**  Ограничение  доступа  к  данным  для  разных  пользователей.
    * **Обеспечение целостности:**  Гарантия  согласованности  и  достоверности  данных.
    * **Восстановление данных:**  Восстановление  данных  после  сбоев.

**Роль и место баз данных в современном мире:**

Базы данных играют ключевую роль в современном информационном обществе.  Они используются повсеместно:

* **В бизнесе:**  для  хранения  информации  о  клиентах,  товарах,  заказах,  финансах  и  т.д.
* **В науке  и  образовании:**  для  хранения  и  анализа  научных  данных,  результатов  исследований,  информации  об  обучении  и  т.д.
* **В государственном управлении:**  для  ведения  реестров,  учета  населения,  обработки  налогов  и  т.д.
* **В повседневной  жизни:**  в  социальных  сетях,  интернет-магазинах,  банках,  больницах  и  т.д.

Эффективное использование  баз данных  позволяет  организациям  и  людям:

* **Повышать  эффективность  работы**.
* **Сокращать  издержки**.
* **Улучшать  качество  принятия  решений**.

В  современном  мире  объем  данных  постоянно  растет,  поэтому  базы  данных  становятся  все  более  востребованными  и  важными.  Развитие  новых  технологий,  таких  как  большие  данные  и  облачные  вычисления,  открывает  новые  возможности  для  хранения,  обработки  и  анализа  данных.

## 2. Этапы развития БД.

### Ответ:

Чтобы понять, как базы данных эволюционировали до современного состояния, давайте проследим основные этапы их развития. 

1. **Базы данных на больших ЭВМ (1960-е - начало 1980-х гг.):** 
    * **Централизованное хранение:** Данные хранились на больших и дорогих ЭВМ,  доступ к которым имели ограниченное число пользователей.
    * **Пакетная обработка:**  Запросы на обработку данных формировались заранее и выполнялись в пакетном режиме. 
    * **Иерархические и сетевые модели данных:**  Доминировали модели, основанные на жестких структурах данных,  что затрудняло  изменение  и  масштабирование  баз данных.
    * **Примеры:**  IMS (Information Management System) от IBM,  IDMS (Integrated Database Management System).

2. **Настольные СУБД (1980-е гг.):**
    * **Персональные компьютеры:** Появление ПК сделало  СУБД  доступнее для малого  бизнеса  и  отдельных  пользователей.
    * **Реляционная модель данных:**  Разработанная Эдгаром  Коддом,  она  стала  стандартом  для  настольных  СУБД,  обеспечивая  простоту  и  гибкость  хранения  данных.
    * **Примеры:**  dBase,  FoxPro,  Paradox,  Microsoft  Access.

3. **Клиент-серверные СУБД (1990-е гг.):**
    * **Распределенная архитектура:**  Данные хранятся на сервере,  а  приложения  на  клиентских  машинах  взаимодействуют  с  сервером  по  сети.
    * **SQL:**  Язык  структурированных  запросов  стал  стандартом  для  клиент-серверных  СУБД.
    * **Транзакции:**  СУБД  начали  поддерживать  транзакции,  обеспечивая  целостность  данных  при  параллельной  работе  множества  пользователей.
    * **Примеры:**  Oracle,  Sybase,  Informix,  Microsoft  SQL  Server.

4. **Интернет-СУБД (конец 1990-х - настоящее время):**
    * **Веб-доступ:**  Доступ  к  данным  через  веб-браузер,  что  упростило  разработку  и  использование  приложений  баз данных.
    * **Облачные СУБД:**  Размещение  баз данных  в  облаке  позволяет  организациям  отказаться  от  собственной  инфраструктуры  и  платить  только  за  используемые  ресурсы.
    * **NoSQL:**  Появление  нереляционных  баз данных,  ориентированных  на  хранение  и  обработку  больших  объемов  неструктурированных  данных.
    * **Примеры:**  MySQL,  PostgreSQL,  MongoDB,  Cassandra.

5. **Современные тенденции:**
    * **Большие данные (Big Data):**  Технологии  для  хранения  и  анализа  огромных  объемов  данных,  которые  не  могут  быть  обработаны  традиционными  СУБД.
    * **Искусственный интеллект (ИИ):**  Интеграция  ИИ  в  СУБД  для  автоматизации  задач  администрирования,  оптимизации  запросов  и  анализа  данных.

    
 Каждый  этап  развития  баз данных  был  обусловлен  появлением  новых  технологий  и  растущими  потребностями  пользователей.  Сегодня  базы  данных  продолжают  активно  развиваться,  открывая  новые  возможности  для  хранения,  обработки  и  использования  информации.

## 3. Архитектура БД.

### Ответ:

Когда мы говорим об архитектуре базы данных, мы говорим о том, как организованы компоненты базы данных для обеспечения ее функциональности, производительности и безопасности. 

Классическим примером является **трехуровневая архитектура ANSI-SPARC**, которая разделяет систему баз данных на три уровня:

1. **Внешний уровень (уровень представления):** 
    * **Ориентирован на пользователя:**  Этот уровень описывает,  как данные видят пользователи или приложения.  Он скрывает физическое хранение данных и представляет их в удобном для пользователя формате. 
    * **Несколько представлений:** Разные пользователи или приложения могут иметь разные представления одних и тех же данных. Например,  бухгалтер  может  видеть  информацию  о  зарплате,  а  менеджер  по  персоналу  -  данные  о  квалификации  сотрудников,  хотя  обе  роли  используют  одну  и  ту  же  базу  данных  о  сотрудниках.

2. **Концептуальный уровень (логический уровень):** 
    * **Глобальная структура данных:**  Описывает все данные, хранящиеся в базе данных, и отношения между ними.  Это абстрактное представление базы данных, не зависящее от физического хранения.
    * **Схема базы данных:**  Концептуальная  схема  определяет  сущности,  атрибуты  и  связи  между  ними,  формируя  логическую  структуру  базы  данных.

3. **Внутренний уровень (физический уровень):** 
    * **Физическое хранение:** Описывает,  как данные физически хранятся на устройствах хранения (жесткие диски, SSD и т.д.). 
    * **Детали реализации:** Включает  в  себя  организацию  файлов,  индексов,  разделение  данных  по  разделам  и  другие  аспекты  физического  хранения.  Этот  уровень  скрыт  от  пользователей  и  приложений  и  управляется  СУБД.

**Преимущества трехуровневой архитектуры:**

* **Независимость данных:** Изменения на одном уровне не влияют на другие уровни.  Например,  можно  изменить  способ  физического  хранения  данных  без  необходимости  переписывать  приложения.
* **Гибкость:**  Позволяет  администраторам  баз данных  оптимизировать  производительность  и  безопасность,  не  влияя  на  работу  пользователей.
* **Многопользовательский доступ:**  Разные  пользователи  могут  работать  с  одними  и  теми  же  данными,  видя  их  в  соответствии  со  своими  правами  и  потребностями.

**Важно отметить:** 

Современные СУБД могут иметь более сложные архитектуры,  но  трехуровневая  модель  ANSI-SPARC  остается  фундаментальным  принципом  организации  баз данных.

## 4. Процесс прохождения пользовательского запроса. 

### Ответ:

Давайте представим, что происходит "под капотом" базы данных, когда пользователь или приложение отправляют запрос.  

1. **Формирование запроса:** Пользователь или приложение формулируют запрос на языке SQL или через интерфейс пользователя. 

2. **Передача запроса СУБД:**  Запрос передается системе управления базами данных (СУБД).

3. **Синтаксический анализ:** СУБД проверяет запрос на синтаксические ошибки и разбирает его структуру,  чтобы понять,  какие данные запрашиваются и какие операции необходимо выполнить.

4. **Проверка прав доступа:** СУБД проверяет,  имеет  ли пользователь или приложение  достаточные  права  доступа  к  запрашиваемым  данным  и  операциям.

5. **Оптимизация запроса:** СУБД анализирует различные планы выполнения запроса и выбирает наиболее эффективный план,  который позволит  получить  результат  с  минимальными  затратами  ресурсов.

6. **Генерация плана выполнения:**  СУБД создает план выполнения,  который представляет  собой  последовательность  операций,  необходимых  для  выполнения  запроса.

7. **Выполнение запроса:**  СУБД выполняет  операции,  указанные  в  плане  выполнения,  обращаясь  к  физически  хранящимся  данным.

8. **Возврат результата:** СУБД возвращает  результат  запроса  пользователю  или  приложению.  Результат  может  быть  представлен  в  виде  таблицы,  сообщения  об  ошибке  или  другой  формы,  определенной  в  запросе.

**Важные детали:**

* **Роль метаданных:** На  этапах  проверки  прав  доступа,  оптимизации  и  выполнения  запроса  СУБД  активно  использует  метаданные -  данные  о  данных,  хранящиеся  в  системном  каталоге.
* **Сложность процесса:**  В  реальных  СУБД  процесс  прохождения  запроса  гораздо  сложнее  и  может  включать  дополнительные  этапы,  такие  как  блокировка  данных,  управление  транзакциями  и  обработка  параллельных  запросов.
* **Влияние  на  производительность:**  Эффективность  СУБД  в  значительной  степени  зависит  от  того,  насколько  быстро  она  может  обрабатывать  пользовательские  запросы.  Оптимизация  запросов  является  одной  из  ключевых  задач  СУБД.

Надеюсь,  это  объяснение  было  понятным!  Давайте  перейдем  к  следующему  вопросу.

## 5. Модель данных. Классификация моделей данных.

### Ответ:

Прежде чем углубляться в детали конкретных моделей, давайте определим, что же такое "модель данных".

**Модель данных** - это абстрактное представление структуры данных и связей между ними.  Она  служит  своеобразным  "каркасом",  который  определяет,  как  данные  будут  организованы,  храниться  и  обрабатываться  в  базе  данных. 

Выбор  подходящей  модели  данных  критически  важен  для  успешной  разработки  и  функционирования  базы  данных.

**Классификация моделей данных:**

Существует  множество  различных  моделей  данных,  которые  можно  классифицировать  по  разным  признакам.  Одна  из  наиболее  распространенных  классификаций -  это  деление  на  три  основных  типа:

1. **Теоретико-графовые модели данных:**  В  этих  моделях  данные  представляются  в  виде  узлов  (сущностей)  и  связей  (отношений)  между  ними,  образуя  граф.

    * **Иерархическая модель:**  Данные  организованы  в  виде  дерева,  где  каждый  узел  имеет  одного  родителя  (кроме  корневого).  Пример -  файловая  система.
    * **Сетевая модель:**  Более  гибкая  модель,  в  которой  узел  может  иметь  несколько  родителей.  Пример -  граф  знакомств  в  социальной  сети.

2. **Теоретико-множественные модели данных:**  В  этих  моделях  данные  представляются  в  виде  таблиц  (отношений),  где  каждая  строка  соответствует  отдельной  записи,  а  каждый  столбец -  определенному  атрибуту.

    * **Реляционная модель:**  Наиболее  распространенная  модель  данных,  основанная  на  математической  теории  множеств.  Отличается  простотой,  гибкостью  и  мощным  математическим  аппаратом. 

3. **Объектно-ориентированные модели данных:**  Эти  модели  объединяют  данные  и  операции  над  ними  в  объекты,  что  позволяет  более  естественно  моделировать  объекты  реального  мира.

    * **Объектно-реляционные СУБД:**  Гибридные  системы,  сочетающие  в  себе  возможности  реляционной  и  объектно-ориентированной  моделей.

**Выбор  модели  данных  зависит  от:**

* **Типа  данных:**  Структурированные,  неструктурированные,  полуструктурированные.
* **Требований  к  производительности:**  Чтение,  запись,  обновление  данных.
* **Сложности  запросов:**  Простые  или  сложные  запросы,  аналитика.
* **Масштабируемости:**  Вертикальная  или  горизонтальная  масштабируемость.

**Важно:** 

В  последние  годы  все  большее  распространение  получают  NoSQL  базы  данных,  которые  не  основаны  на  реляционной  модели  и  предназначены  для  работы  с  большими  объемами  неструктурированных  данных.

## 6. Теоретико-графовые модели данных. Иерархическая и сетевая модели.

### Ответ:

Теоретико-графовые модели данных были популярны на ранних этапах развития баз данных. Давайте рассмотрим две основные модели этой категории: 

1. **Иерархическая модель данных:**

    * **Структура:**  Данные  организованы  в  виде  дерева,  где  каждый  узел  представляет  сущность  и  может  иметь  несколько  дочерних  узлов,  но  только  одного  родителя.  Исключение  составляет  корневой  узел,  который  не  имеет  родителя.

    * **Связи:**  Связи  между  сущностями  всегда  типа  "один-ко-многим" (1:M)  и  представляют  собой  отношения  "родитель-потомок".

    * **Пример:**  Типичный  пример  иерархической  модели -  файловая  система,  где  каталоги  являются  родительскими  узлами  для  файлов  и  подкаталогов.

    **Достоинства:**

    * **Простота  понимания  и  реализации**.
    * **Эффективность  обработки  запросов,  основанных  на  иерархических  связях**.

    **Недостатки:**

    * **Сложность  моделирования  связей  "многие-ко-многим"  (M:N)**.  
    * **Зависимость  данных  от  структуры  дерева,  что  затрудняет  изменения  в  схеме  данных**.

2. **Сетевая модель данных:**

    * **Структура:**  Более  гибкая  модель,  позволяющая  сущностям  иметь  несколько  родителей.  Данные  представляются  в  виде  графа,  где  узлы  -  это  сущности,  а  ребра -  связи  между  ними.

    * **Связи:**  Поддерживаются  связи  "один-ко-многим"  (1:M)  и  "многие-ко-многим" (M:N).

    * **Пример:**  Граф  знакомств  в  социальной  сети,  где  пользователи  могут  быть  связаны  друг  с  другом  через  отношения  "друг"  или  "подписчик".

    **Достоинства:**

    * **Более  естественное  моделирование  сложных  связей  между  сущностями**.
    * **Повышенная  гибкость  по  сравнению  с  иерархической  моделью**.

    **Недостатки:**

    * **Более  сложная  реализация  по  сравнению  с  иерархической  моделью**.
    * **Менее  интуитивно  понятная  структура**.


**Сравнение иерархической и сетевой моделей:**

| Характеристика       | Иерархическая модель   | Сетевая модель |
| -------------------- | ---------------------- | -------------- |
| Структура            | Дерево                 | Граф           |
| Типы связей          | 1:M (родитель-потомок) | 1:M,  M:N      |
| Гибкость             | Низкая                 | Выше           |
| Сложность реализации | Низкая                 | Выше           |
| Пример               | Файловая система       | Граф знакомств |

**Важно:** 

Иерархическая  и  сетевая  модели  в  настоящее  время  используются  редко  из-за  своих  ограничений  и  появления  более  гибкой  и  мощной  реляционной  модели.

## 7. Теоретико-множественные модели. Реляционная модель. Основные определения.

### Ответ:

В отличие от теоретико-графовых моделей,  теоретико-множественные модели данных представляют информацию в виде таблиц, что делает их более интуитивно понятными и простыми в использовании. 

**Реляционная модель данных**, разработанная Эдгаром Ф. Коддом в 1970 году, является наиболее ярким представителем этого типа моделей и фактически стала стандартом для современных баз данных. 

Давайте разберем основные определения реляционной модели:

1. **Отношение (relation):**  Двумерная  таблица,  состоящая  из  строк  и  столбцов.  В  контексте  баз  данных  отношение  часто  называют  **таблицей**.

2. **Атрибут (attribute):**  Именованный  столбец  в  отношении,  характеризующий  определенное  свойство  сущности.  Другими  словами - **столбец  таблицы**.

3. **Кортеж (tuple):** Строка  в  отношении,  представляющая  собой  набор  значений  атрибутов,  относящихся  к  одному  экземпляру  сущности.  Проще  говоря - **строка  таблицы**.

4. **Домен (domain):**  Множество  допустимых  значений  для  определенного  атрибута.  Например,  доменом  для  атрибута  "возраст"  может  быть  множество  целых  чисел  от  0  до  120.

5. **Степень (degree)  отношения:**  Количество  атрибутов  в  отношении.

6. **Мощность (cardinality) отношения:**  Количество  кортежей  в  отношении.

7. **Ключ (key):** Атрибут  или  набор  атрибутов,  однозначно  идентифицирующих  кортеж  в  отношении.  Существуют  различные  типы  ключей,  включая:
    * **Первичный ключ (primary key):**  Минимальный  набор  атрибутов,  однозначно  определяющий  каждый  кортеж  в  отношении.  Например,  в  таблице  "Студенты"  первичным  ключом  может  быть  "Номер  студенческого  билета".
    * **Внешний  ключ  (foreign key):**  Атрибут  или  набор  атрибутов  в  одном  отношении,  ссылающийся  на  первичный  ключ  другого  отношения,  устанавливая  связь  между  ними.  Например,  в  таблице  "Оценки"  атрибут  "Номер  студенческого  билета"  может  быть  внешним  ключом,  ссылающимся  на  таблицу  "Студенты".

**Пример:**

| Студент       | Факультет   | Курс |
| ------------- | ----------- | ---- |
| Иванов Иван   | Информатика | 2    |
| Петров Петр   | Математика  | 3    |
| Сидорова Анна | Физика      | 1    |

В данном примере:

* **Отношение:**  Таблица "Студенты".
* **Атрибуты:**  "Студент", "Факультет", "Курс".
* **Кортежи:**  Каждая  строка  таблицы.
* **Домены:**  Например,  доменом  для  атрибута  "Курс"  может  быть  множество  целых  чисел  от  1  до  6.
* **Степень:** 3 (количество  атрибутов).
* **Мощность:** 3 (количество  кортежей).
* **Первичный  ключ:**  Может  быть  составным  ключом  ("Студент",  "Факультет")  или  введен  отдельный  атрибут  "ID".

**Преимущества  реляционной  модели:**

* **Простота  и  наглядность:**  Представление  данных  в  виде  таблиц  легко  понимается  пользователями.
* **Гибкость  и  масштабируемость:**  Модель  легко  адаптируется  к  изменениям  в  данных  и  их  объемах.
* **Мощный  математический  аппарат:**  Теория  множеств  и  предикатная  логика  позволяют  строить  сложные  и  эффективные  запросы.
* **Стандартизация:**  SQL  является  стандартизированным  языком  для  работы  с  реляционными  базами  данных.

Реляционная модель данных -  это  фундамент,  на  котором  построены  большинство  современных  баз  данных.  Понимание  ее  основных  принципов  и  определений  критически  важно  для  всех,  кто  работает  с  базами  данных.

## 8. Этапы проектирования реляционной БД.

### Ответ:

Проектирование реляционной базы данных - это комплексный процесс, который требует тщательного планирования и выполнения определенных этапов для обеспечения ее эффективности, целостности и соответствия требованиям. 

Вот основные этапы проектирования реляционной БД:

1. **Анализ требований:**

    * **Сбор информации:**  На  этом  этапе  важно  взаимодействовать  с  заказчиками  и  пользователями  будущей  базы  данных,  чтобы  выявить  их  потребности  и  требования  к  системе.
    * **Определение  целей:**  Необходимо  четко  понять,  какие  задачи  будет  решать  база  данных,  какую  информацию  она  будет  хранить  и  какие  операции  над  ней  будут  выполняться.
    * **Формализация требований:**  Собранная  информация  должна  быть  задокументирована  в  виде  ясных  и  понятных  требований  к  функциональности,  производительности,  безопасности  и  другим  аспектам  будущей  базы  данных.

2. **Инфологическое проектирование:**

    * **Создание ER-диаграммы:**  На  этом  этапе  происходит  абстрактное  моделирование  предметной  области  с  помощью  модели  "сущность-связь" (ER-диаграммы).  Определяются  сущности,  их  атрибуты  и  связи  между  ними  без  учета  конкретной  СУБД  или  физической  реализации.
    * **Цель:**  Создать  логически  целостную  и  понятную  модель  данных,  которая  отражает  структуру  и  взаимосвязи  объектов  реального  мира.

3. **Даталогическое проектирование:**

    * **Выбор СУБД:**  Определяется  конкретная  система  управления  базами  данных (СУБД),  которая  будет  использоваться  для  реализации  базы  данных.  Выбор  СУБД  зависит  от  множества  факторов,  таких  как  тип  данных,  требования  к  производительности,  бюджет  и  т.д.
    * **Преобразование  ER-диаграммы  в  схему  базы  данных:**  ER-диаграмма,  созданная  на  предыдущем  этапе,  преобразуется  в  конкретную  схему  базы  данных  с  учетом  особенностей  выбранной  СУБД.  Сущности  становятся  таблицами,  атрибуты  -  столбцами,  а  связи  -  внешними  ключами. 
    * **Нормализация:** Процесс  устранения  избыточности  данных  и  обеспечения  их  целостности  путем  приведения  отношений  (таблиц)  к  определенным  нормальным  формам.

4. **Физическое проектирование:**

    * **Определение  физической  структуры  хранения:**  На  этом  этапе  принимаются  решения  о  том,  как  данные  будут  физически  храниться  на  дисках:  размеры  блоков  данных,  методы  доступа,  индексы  и  т.д. 
    * **Цель:**  Оптимизация  производительности  базы  данных  с  учетом  характера  запросов  и  объема  данных.

5. **Реализация:** 

    * **Создание  базы  данных:**  Используя  язык  определения  данных  (DDL)  выбранной  СУБД,  создаются  таблицы,  индексы,  ограничения  целостности  и  другие  объекты  базы  данных.
    * **Заполнение  данными:**  База  данных  наполняется  начальными  данными.

6. **Тестирование:** 

    * **Проверка  функциональности:**  Тщательно  проверяется  работа  всех  функций  и  операций  базы  данных  на  соответствие  требованиям.
    * **Нагрузочное  тестирование:**  Оценивается  производительность  базы  данных  при  реальных  нагрузках. 

7. **Внедрение  и  сопровождение:** 

    * **Перенос  данных:**  Если  необходимо,  данные  из  старых  систем  переносятся  в  новую  базу  данных.
    * **Обучение  пользователей:**  Пользователи  обучаются  работе  с  новой  системой.
    * **Мониторинг  и  оптимизация:**  После  внедрения  проводится  регулярный  мониторинг  работы  базы  данных,  а  также  ее  оптимизация  для  обеспечения  необходимой  производительности  и  надежности. 

**Важно:**  

Этапы  проектирования  могут  выполняться  не  строго  последовательно.  Часто  приходится  возвращаться  к  предыдущим  этапам  для  уточнения  требований,  корректировки  модели  данных  или  оптимизации  физической  реализации.

Помните,  что  хорошо  спроектированная  база  данных -  это  залог  успешной  работы  информационной  системы!

## 9. Системный анализ предметной области. Пример.

### Ответ:

Системный анализ предметной области - это первый и очень важный этап проектирования базы данных.  Он заключается в сборе, анализе и формализации информации о той части реального мира,  которую мы хотим отразить в базе данных. 

**Цель системного анализа:**

* **Понять структуру и взаимосвязи объектов предметной области**.
* **Определить информационные потребности пользователей**.
* **Сформулировать требования к будущей базе данных**.

**Задачи системного анализа:**

* **Изучение предметной области:** Сбор информации из различных источников (документация,  интервью с экспертами,  наблюдение за бизнес-процессами).
* **Выделение сущностей и атрибутов:**  Определение ключевых объектов предметной области (сущностей) и их характеристик (атрибутов).
* **Определение связей между сущностями:**  Выявление отношений между объектами, таких как "один-ко-многим", "многие-ко-многим" и т.д.
* **Формализация требований:**  Описание требований к функциональности, производительности,  безопасности и другим аспектам будущей базы данных.

**Пример:**

Представим, что нам нужно разработать базу данных для интернет-магазина,  продающего книги.

**1. Изучение предметной области:**

* **Объекты:** Книги,  авторы,  издательства,  жанры,  заказы,  покупатели,  корзина.
* **Характеристики объектов:**
    * **Книга:**  название,  автор,  издательство,  год издания,  ISBN,  цена,  описание,  обложка.
    * **Автор:**  имя,  фамилия,  биография.
    * **Заказ:**  дата заказа,  статус заказа,  способ доставки,  адрес доставки.
    * **Покупатель:**  имя,  фамилия,  email,  телефон,  адрес.

**2. Выделение сущностей и атрибутов:**

* **Сущности:**  Книга,  Автор,  Издательство,  Жанр,  Заказ,  Покупатель,  Корзина.

**3. Определение связей между сущностями:**

* **Книга - Автор:**  Многие-ко-многим (одна книга может иметь несколько авторов,  и один автор может написать несколько книг).
* **Книга - Издательство:**  Многие-к-одному (одна книга издается одним издательством,  но одно издательство может выпустить много книг).
* **Книга - Жанр:**  Многие-ко-многим (одна книга может относиться к нескольким жанрам,  и один жанр может включать много книг).
* **Заказ - Покупатель:**  Многие-к-одному (один заказ оформляется одним покупателем,  но один покупатель может сделать много заказов).
* **Заказ - Книга:**  Многие-ко-многим (один заказ может содержать несколько книг,  и одна книга может входить в разные заказы).
* **Корзина - Покупатель:**  Один-к-одному (у каждого покупателя одна корзина).
* **Корзина - Книга:**  Многие-ко-многим (в корзине может быть несколько книг,  и одна книга может находиться в разных корзинах).

**4. Формализация требований:**

* **Функциональность:**  Поиск книг по различным критериям,  оформление заказа,  управление корзиной,  личным кабинетом покупателя.
* **Производительность:**  Быстрый  поиск  и  загрузка  страниц,  обработка  большого  количества  заказов.
* **Безопасность:**  Защита  персональных  данных  покупателей,  защита  от  несанкционированного  доступа  к  данным.

**Результат системного анализа:**

* **Описание предметной области:**  Документ,  содержащий  информацию  о  сущностях,  атрибутах,  связях  и  требованиях  к  базе  данных.

**Важно:**

* Результаты  системного  анализа  служат  основой  для  дальнейшего  проектирования  базы  данных  (инфологического  и  даталогического).
* Важно  вовлекать  заказчиков  и  пользователей  в  процесс  системного  анализа,  чтобы  учесть  их  потребности  и  обеспечить  соответствие  разрабатываемой  базы  данных  их  ожиданиям.

## 10. Инфологическое проектирование. Модель «сущность – связь».

### Ответ:

Инфологическое проектирование -- это следующий шаг после системного анализа.  Здесь мы берем собранную информацию и создаем абстрактную модель данных, которая отражает структуру предметной области, не вдаваясь в детали реализации в конкретной СУБД.

**Модель «сущность – связь» (ER-модель, Entity-Relationship Model):**

ER-модель -- это графический язык для представления сущностей, их атрибутов и связей между ними. Она является стандартом де-факто для инфологического моделирования баз данных.

**Основные компоненты ER-модели:**

1. **Сущность (Entity):**

   * **Определение:**  Отдельный  объект  или  класс  однотипных  объектов  предметной  области,  о  котором  необходимо  хранить  информацию.  Например:  "Студент",  "Книга",  "Заказ".
   * **Графическое  обозначение:**  Прямоугольник.

2. **Атрибут (Attribute):**

   * **Определение:**  Свойство  или  характеристика  сущности.  Например:  "Имя  студента",  "Название  книги",  "Дата  заказа".
   * **Графическое  обозначение:**  Эллипс,  связанный  с  сущностью  линией.
   * **Типы  атрибутов:**
       * **Простые (Simple):**  Неделимые  значения.  Например:  "Возраст",  "Цена".
       * **Составные (Composite):**  Состоят  из  нескольких  простых  атрибутов.  Например:  "Адрес"  (улица,  дом,  квартира).
       * **Многозначные (Multi-valued):**  Могут  принимать  несколько  значений  одновременно.  Например:  "Номера  телефонов",  "Авторы  книги".
       * **Производные (Derived):**  Вычисляются  на  основе  других  атрибутов.  Например:  "Возраст"  (вычисляется  на  основе  даты  рождения).

3. **Связь (Relationship):**

   * **Определение:**  Отношение  между  двумя  сущностями.  Например:  "Студент  посещает  курс",  "Клиент  делает  заказ".
   * **Графическое  обозначение:**  Ромб,  связанный  с  сущностями  линиями.
   * **Тип  связи  (по  количеству  участвующих  сущностей):**
       * **Бинарная (Binary):**  Связывает  две  сущности.
       * **Тернарная (Ternary):**  Связывает  три  сущности. 
   * **Модальность  связи  (обязательность  участия  сущности  в  связи):**
       * **Обязательная:**  Каждая  сущность  обязательно  должна  участвовать  в  связи. 
       * **Необязательная:**  Сущность  может  не  участвовать  в  связи.
   * **Кратность  связи  (количество  экземпляров  одной  сущности,  связанных  с  одним  экземпляром  другой  сущности):**
       * **Один-к-одному  (1:1):**  Одному  экземпляру  первой  сущности  соответствует  не  более  одного  экземпляра  второй  сущности,  и  наоборот. 
       * **Один-ко-многим  (1:M):**  Одному  экземпляру  первой  сущности  может  соответствовать  несколько  экземпляров  второй  сущности,  но  каждый  экземпляр  второй  сущности  связан  только  с  одним  экземпляром  первой  сущности. 
       * **Многие-ко-многим  (M:N):**  Одному  экземпляру  первой  сущности  может  соответствовать  несколько  экземпляров  второй  сущности,  и  наоборот.

**Пример ER-диаграммы:**

[Изображение ER-диаграммы для примера с книжным интернет-магазином]

**Преимущества ER-модели:**

* **Наглядность:**  Графическое  представление  облегчает  понимание  структуры  данных.
* **Универсальность:**  ER-модель  не  зависит  от  конкретной  СУБД.
* **Простота  использования:**  Существуют  удобные  инструменты  для  построения  ER-диаграмм.

**Важно:**  

ER-диаграмма - это  первый  шаг  к  созданию  базы  данных.  На  следующем  этапе  (даталогическое  проектирование)  она  будет  преобразована  в  конкретную  схему  базы  данных.

## 11. Инфологическое проектирование. Расширенная модель «сущность – связь».

### Ответ:

Расширенная модель "сущность-связь" (EER, Enhanced Entity-Relationship Model) - это надстройка над классической ER-моделью,  предоставляющая дополнительные возможности для более точного и выразительного моделирования предметной области. 

**Ключевые расширения EER-модели:**

1. **Специализация/Обобщение (Specialization/Generalization):**

    * **Специализация:**  Процесс  создания  подтипов  (subtypes)  сущностей,  которые  наследуют  атрибуты  и  связи  от  супертипа (supertype)  и  добавляют  свои  собственные.  Например,  "Студент"  может  быть  супертипом  для  подтипов  "Бакалавр",  "Магистр"  и  "Аспирант". 
    * **Обобщение:**  Обратный  процесс -  выделение  общего  супертипа  для  нескольких  подтипов. 
    * **Графическое  обозначение:**  Треугольник,  соединяющий  супертип  с  подтипами.

2. **Категоризация (Categorization):**

    * **Определение:**  Позволяет  объединять  экземпляры  сущностей  в  категории  на  основе  общих  характеристик.  Например,  сущность  "Сотрудник"  может  иметь  категории  "Штатный",  "Внештатный",  "Совместитель".
    * **Графическое  обозначение:**  Круг,  соединенный  линиями  с  сущностями,  образующими  категорию.

3. **Агрегация (Aggregation):**

    * **Определение:**  Представляет  собой  отношение  "часть-целое"  между  сущностями.  Например,  "Компьютер"  может  состоять  из  сущностей  "Процессор",  "Память",  "Жесткий  диск"  и  т.д. 
    * **Графическое  обозначение:**  Ромб  с  закрашенным  треугольником  со  стороны  "целого".

4. **Составная  сущность  (Composite  Entity):**

    * **Определение:**  Сущность,  которая  зависит  от  существования  других  сущностей  и  не  имеет  собственного  первичного  ключа.  Например,  сущность  "Оценка"  в  отношении  "Студент-Курс-Оценка".
    * **Графическое  обозначение:**  Прямоугольник  с  двойной  рамкой.

**Пример EER-диаграммы:**

[Изображение EER-диаграммы для примера с книжным интернет-магазином, где показаны: специализация сущности "Пользователь" на "Покупатель" и "Администратор",  агрегация сущностей "Город", "Улица", "Дом" в сущность "Адрес" и категоризация сущности "Книга" по "Бумажная" и "Электронная"]

**Преимущества EER-модели:**

* **Повышенная  выразительность:**  Позволяет  моделировать  более  сложные  отношения  и  ограничения.
* **Улучшенная  читаемость:**  EER-диаграммы  более  информативны  и  легче  для  понимания.
* **Ближе  к  объектно-ориентированному  подходу:**  EER-модель  содержит  концепции,  близкие  к  объектно-ориентированному  программированию,  что  облегчает  последующую  реализацию.

**Важно:** 

Несмотря на  дополнительные  возможности,  EER-модель  остается  расширением  классической  ER-модели.  Все  основные  принципы  и  понятия  ER-модели  сохраняются  и  в  EER-модели.

## 12. Преобразование ER-модели в реляционную модель данных.

### Ответ:

После того как мы создали ER-диаграмму, отражающую структуру предметной области,  необходимо преобразовать ее в реляционную модель данных,  которую можно реализовать с помощью конкретной СУБД. 

**Процесс преобразования:**

1. **Преобразование сущностей:**

   * **Каждая сущность становится таблицей:**  Имя  сущности  становится  именем  таблицы.
   * **Атрибуты сущности становятся столбцами таблицы:**  Имена  атрибутов  становятся  именами  столбцов,  а  типы  данных  атрибутов  преобразуются  в  соответствующие  типы  данных  СУБД.

2. **Преобразование связей:**

    * **Связи "один-ко-многим" (1:M):**
        * **Внешний  ключ  в  таблице  "многие":** В  таблицу,  находящуюся  на  стороне  "многие"  связи,  добавляется  внешний  ключ,  ссылающийся  на  первичный  ключ  таблицы  на  стороне  "один".
        * **Пример:**  Если  у  нас  есть  сущности  "Автор" (1)  и  "Книга" (M),  связанные  отношением  "написал",  то  в  таблицу  "Книга"  будет  добавлен  внешний  ключ  "ID_автора",  ссылающийся  на  первичный  ключ  "ID"  в  таблице  "Автор".
    * **Связи "многие-ко-многим" (M:N):**
        * **Создание  промежуточной  таблицы:**  Создается  новая  таблица,  которая  будет  хранить  пары  первичных  ключей  связанных  таблиц.  Эта  таблица  называется  промежуточной  или  ассоциативной.
        * **Пример:**  Если  у  нас  есть  сущности  "Книга" (M)  и  "Жанр" (M),  связанные  отношением  "относится  к",  то  создается  промежуточная  таблица  "Книга_Жанр"  с  внешними  ключами  "ID_книги"  и  "ID_жанра",  ссылающимися  на  соответствующие  таблицы.
    * **Связи "один-к-одному" (1:1):**
        * **Варианты  реализации:**  Могут  быть  реализованы  различными  способами,  например,  путем  добавления  внешнего  ключа  в  одну  из  таблиц  или  объединения  сущностей  в  одну  таблицу.  Выбор  зависит  от  конкретной  ситуации  и  требований  к  производительности.

3. **Преобразование  атрибутов:**

   * **Простые атрибуты:**  Преобразуются  в  соответствующие  столбцы  с  типами  данных. 
   * **Составные атрибуты:**  Можно  разделить  на  несколько  столбцов  или  хранить  как  единое  значение  в  одном  столбце,  в  зависимости  от  требований  к  поиску  и  фильтрации  данных. 
   * **Многозначные атрибуты:**  Обычно  создается  отдельная  таблица  для  хранения  множества  значений,  связанная  с  основной  таблицей  отношением  "один-ко-многим".
   * **Производные  атрибуты:**  Могут  быть  реализованы  как  вычисляемые  столбцы  или  представления,  либо  рассчитываться  программным  кодом  при  необходимости. 

4. **Определение первичных ключей:**

   * **Выбор  первичных  ключей  для  каждой  таблицы:**  Первичный  ключ  должен  быть  уникальным  и  не  должен  принимать  значение  NULL. 

**Пример преобразования:**

[Изображение примера преобразования части ER-диаграммы с книгами и авторами в реляционную модель]

**Важно:**

* Преобразование ER-модели в реляционную  --  это  не  всегда  однозначный  процесс.  Возможны  разные  варианты  реализации  связей  и  атрибутов,  и  выбор  оптимального  варианта  зависит  от  конкретных  требований  и  особенностей  проектируемой  базы  данных.

## 13. Правила реляционной модели. 

### Ответ:

Реляционная модель,  предложенная Эдгаром Ф. Коддом, не просто описывает способ организации данных в виде таблиц. Она также определяет ряд правил, которые гарантируют логическую непротиворечивость,  гибкость и  масштабируемость реляционных баз данных. 

Эти правила, часто называемые правилами Кодда,  можно условно разделить на две группы:

**1. Фундаментальные правила (1-12):**

  * **Правило 0 (основное правило):**  Для того чтобы считаться реляционной, система управления базами данных должна использовать свои реляционные возможности для управления данными. 

  * **Правило 1 (правило информации):** Вся информация в реляционной базе данных представлена одним способом -  в виде значений в ячейках таблиц.

  * **Правило 2 (правило гарантированного доступа):**  К  каждому  отдельного  значению  в  базе  данных  можно  обратиться,  используя  имя  таблицы,  значение  первичного  ключа  и  имя  столбца.

  * **Правило 3 (правило систематической обработки Null-значений):** Null-значения (отсутствие значения) должны поддерживаться системой единообразно и не зависеть от типа данных.

  * **Правило 4 (активный онлайн-каталог на основе реляционной модели):**  Описание  схемы  базы  данных  (метаданные)  должно  храниться  в  реляционных  таблицах  и  быть  доступным  для  пользователей  через  стандартный  язык  запросов.

  * **Правило 5 (правило всеобъемлющего языка данных):**  Система  должна  поддерживать  хотя  бы  один  реляционный  язык  с  линейным  синтаксисом,  который  можно  использовать  как  интерактивно,  так  и  в  прикладных  программах  для  определения  данных,  манипулирования  ими,  управления  доступом  и  транзакциями.

  * **Правило 6 (правило обновления представлений):**  Все  представления,  которые  теоретически  могут  быть  обновлены,  должны  обновляться  системой.

  * **Правило 7 (высокоуровневое  вставка,  обновление,  удаление):** Система  должна  поддерживать  операции  не  только  над  отдельными  строками,  но  и  над  множествами  строк. 

  * **Правило 8 (физическая  независимость  данных):**  Изменения  в  физическом  уровне  (способы  хранения,  размещения  данных)  не  должны  влиять  на  работу  приложений,  если  только  они  не  изменяют  логическую  схему  данных.

  * **Правило 9 (логическая  независимость  данных):**  Изменения  в  логическом  уровне  (например,  добавление  нового  столбца  в  таблицу)  не  должны  требовать  изменения  приложений,  которые  не  используют  этот  столбец. 

  * **Правило 10 (независимость  целостности):**  Ограничения  целостности  должны  быть  определены  отдельно  от  прикладных  программ  и  храниться  в  системе.

  * **Правило 11 (независимость  от  распределения):**  СУБД  может  работать  с  распределенными  данными,  при  этом  прикладные  программы  не  должны  знать  об  этом.

**2. Правила расширения (13-14):**

   * **Правило 13 (правило  неподрывной  реляционности):**  Низкоуровневый  язык  доступа  к  данным  не  должен  нарушать  правила  реляционной  модели.

   * **Правило 14 (правило  отсутствия  указателей):**  Пользователи  не  должны  иметь  возможности  обходить  реляционную  модель  и  манипулировать  данными  напрямую,  используя  указатели  или  другие  низкоуровневые  механизмы.

**Значение правил Кодда:**

*  Правила  Кодда  являются  фундаментальными  принципами  проектирования  реляционных  баз  данных. 
*  Они  гарантируют,  что  база  данных  будет  логически  непротиворечивой,  гибкой,  масштабируемой  и  безопасной.

**Важно:**

* Не  все  современные  СУБД  в  полной  мере  соответствуют  всем  правилам  Кодда,  однако  большинство  из  них  стремятся  к  максимальному  их  соблюдению.

## 14. Нормализация отношений. Функциональные зависимости атрибутов. Аномалии модификации.

### Ответ:

Нормализация -- это процесс оптимизации структуры реляционной базы данных,  направленный на устранение избыточности данных и повышение их целостности.  Она базируется на концепции **функциональных зависимостей** между атрибутами.

**Функциональная зависимость (ФЗ):**

* **Определение:**  Атрибут B **функционально зависит** от атрибута A (A → B),  если каждому значению A соответствует **не более одного** значения B. 
* **Пример:** В таблице "Студенты"  с  атрибутами "НомерСтудБилета", "ФИО", "Группа"  атрибут "ФИО" функционально зависит от "НомерСтудБилета",  поскольку  у  каждого  студента  только  одно  ФИО.

**Транзитивная зависимость:**

* **Определение:**  Атрибут C **транзитивно зависит** от атрибута A (A → C),  если существует атрибут B,  такой что A → B и B → C.
* **Пример:**  Если в  таблице  "Сотрудники"  с  атрибутами  "ТабельныйНомер",  "Отдел",  "Зарплата"  атрибут  "Отдел"  определяет  "Зарплату",  то  "Зарплата"  транзитивно  зависит  от  "ТабельныйНомер".

**Аномалии модификации:**

Избыточность данных,  вызванная  нарушением  нормальных  форм,  может  приводить  к  **аномалиям  модификации**,  которые  усложняют  обновление,  вставку  и  удаление  данных:

* **Аномалия обновления:** Изменение  одного  значения  может  потребовать  изменения  многих  строк.  Например,  если  в  таблице  "Сотрудники"  хранится  название  отдела  и  зарплата  для  каждого  сотрудника,  то  изменение  зарплаты  для  всех  сотрудников  одного  отдела  потребует  обновления  многих  строк.
* **Аномалия вставки:**  Невозможность  добавить  новую  запись  без  ввода  данных,  не  связанных  с  основной  сущностью.  Например,  если  в  таблице  "Книги"  хранится  информация  об  авторах,  то  невозможно  добавить  новую  книгу,  не  указав  автора.
* **Аномалия удаления:**  Удаление  одной  записи  может  привести  к  потере  информации  о  другой  сущности.  Например,  если  в  таблице  "Книги"  хранится  информация  об  авторах,  то  удаление  последней  книги  определенного  автора  приведет  к  потере  информации  об  этом  авторе.

**Нормализация отношений:**

* **Цель:**  Устранить  избыточность  данных  и  аномалии  модификации.
* **Метод:**  Последовательное  приведение  отношений  к  **нормальным  формам**  (НФ).

**Нормальные формы:**

* **1NF (Первая нормальная форма):**  В  отношении  нет  повторяющихся  групп  атрибутов,  все  значения  атомарны.
* **2NF (Вторая нормальная форма):**  Отношение  находится  в  1NF,  и  все  неключевые  атрибуты  полностью  зависят  от  первичного  ключа.
* **3NF (Третья нормальная форма):**  Отношение  находится  в  2NF,  и  нет  транзитивных  зависимостей  неключевых  атрибутов  от  первичного  ключа.
* **BCNF (Нормальная форма Бойса-Кодда):**  Более  строгая  форма  3NF,  где  каждый  детерминант  является  кандидатом  в  ключи.
* **4NF (Четвертая нормальная форма):**  Отношение  находится  в  BCNF,  и  нет  многозначных  зависимостей.
* **5NF (Пятая нормальная форма):**  Отношение  находится  в  4NF,  и  его  нельзя  разложить  на  отношения  меньшей  степени  без  потери  информации.

**Важно:** 

* Нормализация  до  более  высоких  нормальных  форм  уменьшает  избыточность,  но  может  усложнить  запросы.
* На  практике  чаще  всего  используют  нормализацию  до  3NF,  достигая  баланса  между  целостностью  данных  и  производительностью  запросов.

## 15. Даталогическое проектирование. Первая нормальная форма.

### Ответ:

Даталогическое проектирование - это этап, на котором абстрактная модель данных, созданная на этапе инфологического проектирования, преобразуется в конкретную схему базы данных, учитывая особенности выбранной СУБД. 

Одним из ключевых аспектов даталогического проектирования является нормализация,  направленная на устранение избыточности данных и повышение их целостности.  

**Первая нормальная форма (1NF)** - это самая базовая нормальная форма.  

**Определение:** Отношение находится в 1NF,  если:

1. **Все значения атомарны (неделимы):**  На  пересечении  каждой  строки  и  столбца  должно  находиться  только  одно  значение.  Не  допускаются  списки,  массивы  или  другие  сложные  структуры  данных  в  одной  ячейке.
2. **Нет повторяющихся групп атрибутов:**  Каждый  атрибут  должен  описывать  только  одно  свойство  сущности.  Не  допускается  наличие  нескольких  столбцов  с  одинаковым  смыслом  (например,  "Телефон1",  "Телефон2",  "Телефон3").

**Пример отношения, не находящегося в 1NF:**

| Студент     | Телефоны              |
| ----------- | --------------------- |
| Иванов Иван | 123-45-67,  890-12-34 |
| Петров Петр | 567-89-01             |

**Проблемы:**

* **Нарушение атомарности:**  В  столбце  "Телефоны"  хранятся  несколько  значений,  разделенных  запятой.
* **Повторяющиеся  группы  атрибутов:**  Если  студенту  нужно  добавить  еще  один  телефон,  придется  изменить  структуру  таблицы.

**Преобразование в 1NF:**

Чтобы  привести  отношение  к  1NF,  нужно:

1. **Выделить повторяющиеся группы атрибутов:**  В  данном  случае  это  "Телефоны".
2. **Создать  отдельную  таблицу  для  каждой  повторяющейся  группы:**  Новая  таблица  будет  связана  с  основной  таблицей  отношением  "один-ко-многим".

**Нормализованное отношение (в 1NF):**

**Таблица "Студенты":**

| СтудентID | Студент     |
| --------- | ----------- |
| 1         | Иванов Иван |
| 2         | Петров Петр |

**Таблица "Телефоны":**

| СтудентID | Телефон   |
| --------- | --------- |
| 1         | 123-45-67 |
| 1         | 890-12-34 |
| 2         | 567-89-01 |

**Преимущества 1NF:**

* **Устранение  избыточности  данных:**  Каждый  телефон  теперь  хранится  в  отдельной  строке,  что  исключает  дублирование.
* **Упрощение  модификации  данных:**  Добавление  нового  телефона  для  студента  требует  только  добавления  новой  строки  в  таблицу  "Телефоны".

**Важно:** 

* 1NF -  это  самая  базовая  форма,  и  она  не  гарантирует  полного  отсутствия  избыточности  и  аномалий  модификации.  
* Для  дальнейшей  оптимизации  структуры  базы  данных  необходимо  приводить  отношения  к  более  высоким  нормальным  формам.

## 16. Даталогическое проектирование. Вторая нормальная форма.

### Ответ:

Переход ко второй нормальной форме (2NF) становится актуальным, когда в таблицах присутствуют составные первичные ключи,  то есть ключи,  состоящие из  нескольких атрибутов. 

**Определение:** Отношение находится в 2NF, если:

1. **Оно находится в 1NF.**
2. **Все неключевые атрибуты полностью зависят от всего составного первичного ключа,  а не от его части.**

**Пример отношения, не находящегося в 2NF:**

Рассмотрим таблицу "Заказы",  где первичный ключ состоит из атрибутов "НомерЗаказа" и "КодТовара":

| НомерЗаказа | КодТовара | НазваниеТовара | ЦенаТовара | ФИОКлиента  |
| ----------- | --------- | -------------- | ---------- | ----------- |
| 1           | A1        | Книга          | 10         | Иванов Иван |
| 1           | B2        | Тетрадь        | 2          | Иванов Иван |
| 2           | A1        | Книга          | 10         | Петров Петр |

**Проблема:**

* Атрибуты "НазваниеТовара"  и  "ЦенаТовара" зависят только от части первичного ключа - "КодТовара",  а  не  от  всего  ключа  ("НомерЗаказа",  "КодТовара").

**Последствия:**

* **Избыточность данных:**  Информация  о  названии  и  цене  товара  дублируется  для  каждого  заказа,  в  котором  он  присутствует.
* **Аномалия  обновления:**  Если  изменится  название  или  цена  товара,  придется  обновить  множество  строк  в  таблице.

**Преобразование в 2NF:**

Чтобы привести отношение к 2NF, нужно:

1. **Выделить  атрибуты,  зависящие  от  части  первичного  ключа:**  В  данном  случае  это  "НазваниеТовара"  и  "ЦенаТовара".
2. **Создать  новую  таблицу  для  этих  атрибутов  и  части  ключа,  от  которой  они  зависят:**  Новая  таблица  будет  иметь  первичный  ключ  "КодТовара".

**Нормализованные отношения (в 2NF):**

**Таблица "Заказы":**

| НомерЗаказа | КодТовара | ФИОКлиента  |
| ----------- | --------- | ----------- |
| 1           | A1        | Иванов Иван |
| 1           | B2        | Иванов Иван |
| 2           | A1        | Петров Петр |

**Таблица "Товары":**

| КодТовара | НазваниеТовара | ЦенаТовара |
| --------- | -------------- | ---------- |
| A1        | Книга          | 10         |
| B2        | Тетрадь        | 2          |

**Преимущества 2NF:**

* **Устранение избыточности данных:**  Информация  о  товарах  хранится  только  в  одном  месте.
* **Упрощение модификации данных:**  Изменение  информации  о  товаре  требует  обновления  только  одной  строки  в  таблице  "Товары".

**Важно:**

* 2NF  устраняет  только  частичные  зависимости  от  первичного  ключа.  
* Для  полного  устранения  избыточности  и  аномалий  модификации  необходимо  приводить  отношения  к  3NF. 

## 17. Даталогическое проектирование. Третья нормальная форма.

### Ответ:

Третья нормальная форма (3NF) - это следующий шаг в процессе нормализации,  который устраняет транзитивные зависимости,  обеспечивая  еще  большую  целостность  данных.

**Определение:** Отношение находится в 3NF,  если:

1. **Оно  находится  в  2NF.**
2. **Нет  транзитивных  зависимостей  неключевых  атрибутов  от  первичного  ключа.** 

Другими словами,  каждый  неключевой  атрибут  должен  зависеть  **только**  от  первичного  ключа,  а  не  от  других  неключевых  атрибутов.

**Пример отношения, не находящегося в 3NF:**

Рассмотрим  таблицу  "Сотрудники":

| ТабельныйНомер | ФИО           | Отдел | НазваниеОтдела |
| -------------- | ------------- | ----- | -------------- |
| 1              | Иванов Иван   | 101   | IT             |
| 2              | Петров Петр   | 102   | Бухгалтерия    |
| 3              | Сидорова Анна | 101   | IT             |

**Проблема:**

* Атрибут "НазваниеОтдела"  транзитивно  зависит  от  первичного  ключа  "ТабельныйНомер"  через  атрибут  "Отдел".  

**Последствия:**

* **Избыточность данных:**  Название  отдела  дублируется  для  каждого  сотрудника  этого  отдела.
* **Аномалия  обновления:**  Если  изменится  название  отдела,  придется  обновить  множество  строк  в  таблице.

**Преобразование в 3NF:**

Чтобы привести отношение к 3NF,  нужно:

1. **Выделить  атрибуты,  транзитивно  зависящие  от  первичного  ключа:**  В  данном  случае  это  "НазваниеОтдела".
2. **Создать  новую  таблицу  для  этих  атрибутов  и  атрибута,  от  которого  они  зависят:**  Новая  таблица  будет  иметь  первичный  ключ  "Отдел".

**Нормализованные отношения (в 3NF):**

**Таблица "Сотрудники":**

| ТабельныйНомер | ФИО           | Отдел |
| -------------- | ------------- | ----- |
| 1              | Иванов Иван   | 101   |
| 2              | Петров Петр   | 102   |
| 3              | Сидорова Анна | 101   |

**Таблица "Отделы":**

| Отдел | НазваниеОтдела |
| ----- | -------------- |
| 101   | IT             |
| 102   | Бухгалтерия    |

**Преимущества 3NF:**

* **Устранение избыточности данных:**  Информация  об  отделах  хранится  только  в  одном  месте.
* **Упрощение модификации данных:**  Изменение  названия  отдела  требует  обновления  только  одной  строки  в  таблице  "Отделы".

**Важно:**

* 3NF  является  наиболее  распространенной  нормальной  формой  на  практике.  
* Она  обеспечивает  хороший  баланс  между  целостностью  данных  и  производительностью  запросов.
* Существуют  более  высокие  нормальные  формы  (BCNF,  4NF,  5NF),  но  они  используются  реже  из-за  усложнения  схемы  базы  данных  и  запросов.

## 18. Даталогическое проектирование. Нормальная форма Бойса-Кодда.

### Ответ:

Нормальная форма Бойса-Кодда (BCNF, Boyce-Codd Normal Form) - это более строгая версия 3NF, которая устраняет некоторые аномалии,  которые могут  возникнуть  даже  в  отношениях,  находящихся  в  3NF. 

**Определение:**  Отношение  находится  в  BCNF,  если:

1. **Оно  находится  в  3NF.**
2. **Каждый  детерминант  является  кандидатом  в  ключи.**

**Детерминант:**  Атрибут  или  совокупность  атрибутов,  от  которых  полностью  функционально  зависит  какой-либо  другой  атрибут.

**Кандидат в ключи:**  Атрибут  или  совокупность  атрибутов,  которые  могут  служить  первичным  ключом  отношения  (то есть  однозначно  идентифицируют  каждый  кортеж).

**Пример отношения, не находящегося в BCNF:**

| Студент | Курс | Преподаватель |
| ------- | ---- | ------------- |
| Иванов  | БД   | Петров        |
| Петров  | БД   | Петров        |
| Сидоров | Сети | Иванов        |

**Проблема:**

* Детерминант  "Курс"  определяет  атрибут  "Преподаватель",  но  не  является  кандидатом  в  ключи.  Первичный  ключ  в  этом  отношении -  составной  ("Студент",  "Курс").

**Последствия:**

* **Избыточность данных:**  Информация  о  том,  что  преподаватель  Петров  ведет  курс  "БД",  дублируется.
* **Аномалия  обновления:**  Если  преподаватель  Петров  перестанет  вести  курс  "БД",  придется  обновить  несколько  строк.

**Преобразование в BCNF:**

Чтобы привести отношение к BCNF, нужно:

1. **Выделить  детерминант,  не  являющийся  кандидатом  в  ключи:**  В  данном  случае  это  "Курс".
2. **Разделить  отношение  на  два  отношения:**  Одно  с  первичным  ключом  "Курс"  и  атрибутом  "Преподаватель",  а  другое  с  первичным  ключом  ("Студент",  "Курс").

**Нормализованные отношения (в BCNF):**

**Таблица "Курсы":**

| Курс | Преподаватель |
| ---- | ------------- |
| БД   | Петров        |
| Сети | Иванов        |

**Таблица "Студенты_Курсы":**

| Студент | Курс |
| ------- | ---- |
| Иванов  | БД   |
| Петров  | БД   |
| Сидоров | Сети |

**Преимущества BCNF:**

* **Устранение  избыточности  данных:**  Информация  о  преподавателях  курсов  хранится  только  в  одном  месте.
* **Упрощение  модификации  данных:**  Изменение  преподавателя  курса  требует  обновления  только  одной  строки  в  таблице  "Курсы".

**Важно:**

* BCNF  является  более  строгой  нормальной  формой,  чем  3NF,  но  ее  достижение  не  всегда  возможно  или  целесообразно.
* BCNF  может  увеличить  количество  таблиц  и  усложнить  запросы.

## 19. Реляционная алгебра. Основные операции.

### Ответ:

Реляционная алгебра -- это формальный язык для работы с реляционными данными,  который  позволяет  выражать  запросы  к  базе  данных  в  виде  последовательности  операций  над  отношениями  (таблицами).  

**Основные операции реляционной алгебры:**

1. **Объединение (UNION):**

    * **Обозначение:**  R ∪ S
    * **Определение:**  Возвращает  отношение,  содержащее  все  кортежи,  присутствующие  в  R  или  в  S,  или  в  обоих  отношениях  (без  дубликатов).
    * **Условие:**  R  и  S  должны  иметь  одинаковую  степень  (количество  атрибутов),  и  соответствующие  атрибуты  должны  иметь  совместимые  домены.

2. **Пересечение (INTERSECTION):**

    * **Обозначение:**  R ∩ S
    * **Определение:**  Возвращает  отношение,  содержащее  только  те  кортежи,  которые  присутствуют  как  в  R,  так  и  в  S.
    * **Условие:**  R  и  S  должны  иметь  одинаковую  степень,  и  соответствующие  атрибуты  должны  иметь  совместимые  домены.

3. **Разность (DIFFERENCE):**

    * **Обозначение:**  R - S
    * **Определение:**  Возвращает  отношение,  содержащее  кортежи,  присутствующие  в  R,  но  отсутствующие  в  S.
    * **Условие:**  R  и  S  должны  иметь  одинаковую  степень,  и  соответствующие  атрибуты  должны  иметь  совместимые  домены.

4. **Декартово произведение (PRODUCT):**

    * **Обозначение:**  R × S
    * **Определение:**  Возвращает  отношение,  содержащее  все  возможные  комбинации  кортежей  из  R  и  S.  Степень  результирующего  отношения  равна  сумме  степеней  R  и  S.

5. **Проекция (PROJECTION):**

    * **Обозначение:**  π<sub>A1, A2, ..., An</sub>(R)
    * **Определение:**  Возвращает  отношение,  содержащее  только  указанные  атрибуты  (A1,  A2,  ...,  An)  из  отношения  R.  Дубликаты  кортежей  в  результирующем  отношении  удаляются.

6. **Выборка (SELECTION):**

    * **Обозначение:**  σ<sub>условие</sub>(R)
    * **Определение:**  Возвращает  отношение,  содержащее  только  те  кортежи  из  R,  которые  удовлетворяют  заданному  условию.  Условие  может  включать  операторы  сравнения,  логические  операторы  и  другие  операции. 

**Примеры:**

**Пусть  даны  отношения:**

R = {(1,  a),  (2,  b),  (3,  c)}
S = {(2,  b),  (4,  d)}

* **R ∪ S = {(1,  a),  (2,  b),  (3,  c),  (4,  d)}**
* **R ∩ S = {(2,  b)}**
* **R - S = {(1,  a),  (3,  c)}**
* **R × S = {(1,  a,  2,  b),  (1,  a,  4,  d),  (2,  b,  2,  b),  (2,  b,  4,  d),  (3,  c,  2,  b),  (3,  c,  4,  d)}**
* **π<sub>1</sub>(R) = {(1),  (2),  (3)}**
* **σ<sub>1>2</sub>(R) = {}**

**Важно:**

* Основные  операции  реляционной  алгебры  являются  базовыми  блоками  для  построения  более  сложных  запросов.
* Реляционная  алгебра  является  теоретической  основой  для  языков  запросов,  таких  как  SQL.

## 20. Реляционная алгебра. Дополнительные операции.

### Ответ:

Помимо  основных  операций,  реляционная  алгебра  включает  ряд  дополнительных  операций,  которые  не  расширяют  ее  выразительную  мощность,  но  делают  запросы  более  компактными  и  удобными  для  записи.

**Дополнительные операции реляционной алгебры:**

1. **Соединение (JOIN):**

    * **Обозначение:**  R ⋈<sub>θ</sub> S,  где  θ  -  условие  соединения.
    * **Определение:**  Возвращает  отношение,  содержащее  кортежи  из  R  и  S,  для  которых  выполняется  условие  соединения  θ.  Условие  соединения  обычно  основано  на  сравнении  значений  атрибутов  из  обоих  отношений.
    * **Типы  соединений:**
       * **Внутреннее  соединение  (INNER  JOIN):**  Возвращает  только  те  кортежи,  для  которых  нашлись  совпадения  в  обоих  отношениях.
       * **Левое  внешнее  соединение  (LEFT  OUTER  JOIN):**  Возвращает  все  кортежи  из  левого  отношения  (R),  а  также  совпадающие  кортежи  из  правого  отношения  (S).  Если  для  кортежа  из  R  не  найдено  соответствия  в  S,  то  атрибуты  из  S  заполняются  значениями  NULL.
       * **Правое  внешнее  соединение  (RIGHT  OUTER  JOIN):**  Аналогично  левому  внешнему  соединению,  но  возвращает  все  кортежи  из  правого  отношения  (S).
       * **Полное  внешнее  соединение  (FULL  OUTER  JOIN):**  Возвращает  все  кортежи  из  обоих  отношений,  заполняя  значениями  NULL  отсутствующие  атрибуты  в  случае  несоответствия.

2. **Естественное  соединение  (NATURAL  JOIN):**

    * **Обозначение:**  R ⋈ S
    * **Определение:**  Особый  случай  соединения,  где  условием  является  равенство  значений  всех  общих  атрибутов  R  и  S.  Дубликаты  общих  атрибутов  в  результирующем  отношении  удаляются.

3. **Деление (DIVISION):**

    * **Обозначение:**  R ÷ S
    * **Определение:**  Возвращает  отношение,  содержащее  те  значения  атрибутов  из  R,  которые  комбинируются  со  всеми  значениями  атрибутов  из  S  и  присутствуют  в  R.  Обычно  используется  для  запросов  типа  "найти  всех  X,  которые  связаны  со  всеми  Y".

4. **Переименование  атрибутов (RENAME):**

    * **Обозначение:**  ρ<sub>(B1,  B2,  ...,  Bn)</sub>(R)  или  R(B1,  B2,  ...,  Bn)
    * **Определение:**  Возвращает  отношение  R,  в  котором  атрибуты  переименованы  в  B1,  B2,  ...,  Bn.

**Примеры:**

**Пусть  даны  отношения:**

R = {(1,  a,  x),  (2,  b,  y),  (3,  c,  z)}
S = {(a,  p),  (b,  q)}

* **R ⋈<sub>R.2=S.1</sub> S = {(1,  a,  x,  p),  (2,  b,  y,  q)}**  (внутреннее  соединение)
* **R ⋈ S = {(1,  a,  x,  p),  (2,  b,  y,  q)}**  (естественное  соединение)

**Важно:**

* Дополнительные  операции  реляционной  алгебры  упрощают  запись  запросов,  но  могут  быть  выражены  через  комбинации  основных  операций.
* Понимание  дополнительных  операций  полезно  для  более  эффективного  использования  реляционной  алгебры  и  языков  запросов,  основанных  на  ней.

## 21. Язык SQL. Структура SQL. Типы данных.

### Ответ:

SQL (Structured Query Language) - это  стандартизированный  язык  для  работы  с  реляционными  базами  данных. Он  используется  для  определения  данных,  манипулирования  ими,  управления  доступом  и  других  операций.

**Структура SQL:**

SQL  состоит  из  нескольких  категорий  операторов:

1. **DDL  (Data  Definition  Language  -  язык  определения  данных):**

    * Используется  для  создания,  изменения  и  удаления  объектов  базы  данных  (таблиц,  представлений,  индексов  и  т.д.).
    * **Основные  операторы  DDL:**
        * `CREATE`  (создать)
        * `ALTER`  (изменить)
        * `DROP`  (удалить)

2. **DML  (Data  Manipulation  Language  -  язык  манипулирования  данными):**

    * Используется  для  вставки,  обновления  и  удаления  данных  в  таблицах.
    * **Основные  операторы  DML:**
        * `INSERT`  (вставить)
        * `UPDATE`  (обновить)
        * `DELETE`  (удалить)

3. **DQL  (Data  Query  Language  -  язык  запросов  данных):**

    * Используется  для  извлечения  данных  из  базы  данных.
    * **Основной  оператор  DQL:**
        * `SELECT`  (выбрать)

4. **DCL  (Data  Control  Language  -  язык  управления  данными):**

    * Используется  для  управления  доступом  к  данным  и  привилегиями  пользователей.
    * **Основные  операторы  DCL:**
        * `GRANT`  (предоставить  права)
        * `REVOKE`  (отозвать  права)

5. **TCL  (Transaction  Control  Language  -  язык  управления  транзакциями):**

    * Используется  для  управления  транзакциями,  обеспечивая  целостность  данных.
    * **Основные  операторы  TCL:**
        * `COMMIT`  (зафиксировать  транзакцию)
        * `ROLLBACK`  (откатить  транзакцию)
        * `SAVEPOINT`  (создать  точку  сохранения)

**Типы данных SQL:**

SQL  поддерживает  различные  типы  данных  для  хранения  разной  информации:

* **Числовые:**
    * `INTEGER`,  `INT`  (целые  числа)
    * `SMALLINT`  (целые  числа  меньшего  диапазона)
    * `DECIMAL`,  `NUMERIC`  (числа  с  фиксированной  точностью)
    * `FLOAT`,  `REAL`  (числа  с  плавающей  точкой)
    * `DOUBLE  PRECISION`  (числа  с  плавающей  точкой  двойной  точности)

* **Строковые:**
    * `CHAR`,  `CHARACTER`  (строки  фиксированной  длины)
    * `VARCHAR`  (строки  переменной  длины)
    * `TEXT`  (длинные  текстовые  строки)

* **Дата  и  время:**
    * `DATE`  (дата)
    * `TIME`  (время)
    * `DATETIME`  (дата  и  время)
    * `TIMESTAMP`  (метка  времени)

* **Логический:**
    * `BOOLEAN`

* **Двоичные  данные:**
    * `BLOB`  (двоичные  большие  объекты)

**Важно:**

* Конкретный  набор  типов  данных  и  их  поддерживаемые  параметры  могут  отличаться  в  зависимости  от  СУБД.

## 22. Язык SQL. Операторы определения данных DDL.

### Ответ:

DDL (Data Definition Language - Язык определения данных)  в  SQL  используется  для  создания,  модификации  и  удаления  объектов  базы  данных.  Это  позволяет  определить  схему  базы  данных  и  управлять  ее  структурой.

**Основные операторы DDL:**

1. **`CREATE` (Создать):**

    * **`CREATE TABLE`:**  Создает  новую  таблицу  в  базе  данных,  определяя  ее  столбцы  (атрибуты)  и  их  типы  данных.

        **Пример:**
        ```sql
        CREATE TABLE Студенты (
            ID INT PRIMARY KEY,
            ФИО VARCHAR(255),
            Группа VARCHAR(10)
        );
        ```

    * **`CREATE VIEW`:**  Создает  представление  (view),  которое  является  виртуальной  таблицей,  основанной  на  запросе  `SELECT`.

        **Пример:**
        ```sql
        CREATE VIEW Отличники AS
        SELECT *
        FROM Студенты
        WHERE Оценка = 5;
        ```

    * **`CREATE INDEX`:**  Создает  индекс  для  одного  или  нескольких  столбцов  таблицы,  что  ускоряет  поиск  данных.

        **Пример:**
        ```sql
        CREATE INDEX idx_ФИО 
        ON Студенты (ФИО);
        ```

2. **`ALTER` (Изменить):**

    * **`ALTER TABLE`:**  Изменяет  структуру  существующей  таблицы,  например,  добавляет  новые  столбцы,  удаляет  столбцы  или  изменяет  их  типы  данных.

        **Пример:**
        ```sql
        ALTER TABLE Студенты
        ADD COLUMN ДатаРождения DATE;
        ```

3. **`DROP` (Удалить):**

    * **`DROP TABLE`:**  Удаляет  таблицу  из  базы  данных.

        **Пример:**
        ```sql
        DROP TABLE Студенты;
        ```

    * **`DROP VIEW`:**  Удаляет  представление.

        **Пример:**
        ```sql
        DROP VIEW Отличники;
        ```

    * **`DROP INDEX`:**  Удаляет  индекс.

        **Пример:**
        ```sql
        DROP INDEX idx_ФИО;
        ```

**Важно:**

* Операторы  DDL  изменяют  структуру  базы  данных,  поэтому  их  выполнение  требует  особых  прав  доступа.
* При  использовании  операторов  DDL  следует  быть  осторожным,  так  как  они  могут  привести  к  потере  данных,  если  применяются  неправильно.

## 23. Язык SQL. Операторы манипулирования данными DML.

### Ответ:

DML (Data Manipulation Language - язык манипулирования данными)  в SQL  используется  для  изменения  данных  в  таблицах  базы  данных.  

**Основные операторы DML:**

1. **`INSERT` (Вставить):**

   * **Назначение:**  Добавляет  новую  строку  (запись)  в  таблицу.
   * **Синтаксис:**
     ```sql
     INSERT INTO <имя_таблицы> [(<список_столбцов>)] VALUES (<список_значений>);
     ```
   * **Пример:**
     ```sql
     INSERT INTO Студенты (ID, ФИО, Группа) VALUES (4, 'Сидоров Сидор', '103');
     ```
     Этот  запрос  добавит  нового  студента  с  ID  4,  ФИО  "Сидоров  Сидор"  и  группой  "103"  в  таблицу  "Студенты".

2. **`UPDATE` (Обновить):**

   * **Назначение:**  Изменяет  существующие  значения  в  одной  или  нескольких  строках  таблицы.
   * **Синтаксис:**
     ```sql
     UPDATE <имя_таблицы> SET <столбец1> = <значение1>, <столбец2> = <значение2>, ... WHERE <условие>;
     ```
   * **Пример:**
     ```sql
     UPDATE Студенты SET Группа = '102' WHERE ID = 4;
     ```
     Этот  запрос  изменит  группу  студента  с  ID  4  на  "102".

3. **`DELETE` (Удалить):**

   * **Назначение:**  Удаляет  одну  или  несколько  строк  из  таблицы.
   * **Синтаксис:**
     ```sql
     DELETE FROM <имя_таблицы> WHERE <условие>;
     ```
   * **Пример:**
     ```sql
     DELETE FROM Студенты WHERE ID = 4;
     ```
     Этот  запрос  удалит  студента  с  ID  4  из  таблицы  "Студенты".

**Важно:**

* Операторы  DML  изменяют  данные  в  базе  данных,  поэтому  их  выполнение  требует  особых  прав  доступа.
* При  использовании  операторов  DML  следует  быть  осторожным,  особенно  с  оператором  `DELETE`,  так  как  он  может  привести  к  необратимой  потере  данных.
* Условие  `WHERE`  в  операторах  `UPDATE`  и  `DELETE`  используется  для  указания  строк,  к  которым  должна  быть  применена  операция.  Если  условие  `WHERE`  отсутствует,  то  операция  будет  применена  ко  всем  строкам  в  таблице.

## 24. Язык SQL. Оператор выбора DQL.

### Ответ: 

DQL (Data Query Language - язык запросов данных) в SQL представлен единственным, но очень мощным оператором  `SELECT`.  Он используется для извлечения данных из базы данных,  позволяя формулировать запросы различной сложности. 

**Синтаксис оператора `SELECT`:**

```sql
SELECT [DISTINCT | ALL] <список_полей>
FROM <список_таблиц>
[WHERE <условие_отбора>]
[GROUP BY <список_полей_группировки>]
[HAVING <условие_группировки>]
[ORDER BY <список_полей_сортировки>];
```

**Описание:**

* **`SELECT [DISTINCT | ALL] <список_полей>`:** 
    *  `SELECT` -  ключевое  слово,  указывающее  на  операцию  выборки  данных.
    *  `DISTINCT` -  возвращает  только  уникальные  строки  (без  дубликатов).
    *  `ALL` -  возвращает  все  строки  (по  умолчанию).
    *  `<список_полей>` -  список  столбцов,  которые  необходимо  извлечь.  Может  быть  использована  звездочка  `*`  для  выборки  всех  столбцов.

* **`FROM <список_таблиц>`:**  Указывает  таблицы,  из  которых  необходимо  извлечь  данные.  Если  запрос  обращается  к  нескольким  таблицам,  то  они  перечисляются  через  запятую.

* **`WHERE <условие_отбора>`:**  Необязательное  условие,  которое  ограничивает  выборку  строк,  удовлетворяющих  заданному  условию.  Может  использоваться  с  операторами  сравнения  (`=`,  `<>`,  `>`,  `<`,  `>=`,  `<=`),  логическими  операторами  (`AND`,  `OR`,  `NOT`),  операторами  `IN`,  `BETWEEN`,  `LIKE`  и  т.д.

* **`GROUP BY <список_полей_группировки>`:**  Необязательное  предложение,  которое  группирует  строки  с  одинаковыми  значениями  в  указанных  столбцах.  Часто  используется  с  агрегатными  функциями  (`COUNT`,  `SUM`,  `AVG`,  `MIN`,  `MAX`).

* **`HAVING <условие_группировки>`:**  Необязательное  условие,  которое  фильтрует  группы,  полученные  в  результате  `GROUP BY`.  Аналогично  `WHERE`,  но  применяется  к  группам,  а  не  к  отдельным  строкам.

* **`ORDER BY <список_полей_сортировки>`:**  Необязательное  предложение,  которое  сортирует  результат  запроса  по  указанным  столбцам.  Может  быть  указано  направление  сортировки:  `ASC`  (по  возрастанию,  по  умолчанию)  или  `DESC`  (по  убыванию).

**Примеры:**

* **Выбрать  все  столбцы  из  таблицы  "Студенты":**

```sql
SELECT * FROM Студенты;
```

* **Выбрать  ФИО  и  группу  студентов  с  оценкой  5:**

```sql
SELECT ФИО, Группа
FROM Студенты
WHERE Оценка = 5;
```

* **Выбрать  количество  студентов  в  каждой  группе:**

```sql
SELECT Группа, COUNT(*) AS КоличествоСтудентов
FROM Студенты
GROUP BY Группа;
```

* **Выбрать  группы,  в  которых  более  10  студентов:**

```sql
SELECT Группа, COUNT(*) AS КоличествоСтудентов
FROM Студенты
GROUP BY Группа
HAVING COUNT(*) > 10;
```

* **Выбрать  ФИО  студентов,  отсортированных  по  алфавиту:**

```sql
SELECT ФИО
FROM Студенты
ORDER BY ФИО;
```

**Важно:**

* Оператор  `SELECT`  является  фундаментальным  инструментом  для  извлечения  данных  из  базы  данных.
* Освоение  синтаксиса  и  возможностей  `SELECT`  позволяет  выполнять  запросы  любой  сложности.

## 25. Язык SQL. Горизонтальное соединение таблиц. Функция JOIN.

### Ответ:

Соединение таблиц (JOIN)  в SQL — это операция,  которая  позволяет  объединять  данные  из  двух  или  более  таблиц  на  основе  условия  соединения.  

**Горизонтальное соединение**  —  это  тип  соединения,  при  котором  столбцы  из  разных  таблиц  объединяются  в  одну  результирующую  таблицу,  образуя  более  широкую  таблицу.

**Функция  `JOIN`:**

`JOIN`  —  это  ключевое  слово  в  SQL,  которое  используется  для  выполнения  соединения  таблиц.  

**Синтаксис:**

```sql
SELECT <список_полей>
FROM <таблица1>
[<тип_соединения>] JOIN <таблица2>
ON <условие_соединения>;
```

**Типы  соединений:**

* **`INNER JOIN`  (внутреннее  соединение):**  Возвращает  только  те  строки,  для  которых  условие  соединения  выполняется  в  обоих  таблицах.

* **`LEFT [OUTER] JOIN`  (левое  внешнее  соединение):**  Возвращает  все  строки  из  левой  таблицы  (`таблица1`),  а  также  совпадающие  строки  из  правой  таблицы  (`таблица2`).  Если  для  строки  из  левой  таблицы  нет  соответствия  в  правой,  то  столбцы  из  правой  таблицы  будут  содержать  значения  `NULL`.

* **`RIGHT [OUTER] JOIN`  (правое  внешнее  соединение):**  Аналогично  левому  внешнему  соединению,  но  возвращает  все  строки  из  правой  таблицы.

* **`FULL [OUTER] JOIN`  (полное  внешнее  соединение):**  Возвращает  все  строки  из  обеих  таблиц,  заполняя  значениями  `NULL`  отсутствующие  столбцы  в  случае  несоответствия.

**Условие  соединения:**

Условие  соединения  обычно  задается  с  помощью  оператора  `ON`,  который  указывают,  какие  столбцы  из  двух  таблиц  должны  быть  сравнены.  

**Пример:**

**Пусть  даны  таблицы:**

* **`Студенты`:**  (ID,  ФИО,  Группа)
* **`Оценки`:**  (СтудентID,  Предмет,  Оценка)

**Запрос  с  `INNER JOIN`  для  вывода  ФИО  студента  и  его  оценок:**

```sql
SELECT Студенты.ФИО, Оценки.Предмет, Оценки.Оценка
FROM Студенты
INNER JOIN Оценки ON Студенты.ID = Оценки.СтудентID;
```

**Результат:**

| ФИО           | Предмет    | Оценка |
| ------------- | ---------- | ------ |
| Иванов Иван   | Математика | 5      |
| Иванов Иван   | Физика     | 4      |
| Петров Петр   | Математика | 3      |
| Сидорова Анна | Физика     | 5      |

**Важно:**

* Соединения  таблиц  —  это  мощный  инструмент  для  объединения  данных  из  разных  таблиц.
* Выбор  типа  соединения  зависит  от  того,  какие  данные  необходимо  получить.
* Условие  соединения  должно  быть  корректно  сформулировано,  чтобы  получить  ожидаемый  результат.

## 26. Язык SQL. Операторы управления данными. 

### Ответ: 

В SQL операторы управления данными (DCL, Data Control Language)  предоставляют  средства  для  управления  доступом  к  данным  и  обеспечения  безопасности  базы  данных.  

**Основные операторы DCL:**

1. **`GRANT`  (Предоставить  права):**

    * **Назначение:**  Предоставляет  определенные  привилегии  (права  доступа)  пользователям  или  ролям  на  объекты  базы  данных  (таблицы,  представления,  процедуры  и  т.д.).
    * **Синтаксис:**
      ```sql
      GRANT <привилегии> ON <объект> TO <пользователь/роль> [WITH GRANT OPTION];
      ```
    * **Пример:**
      ```sql
      GRANT SELECT, INSERT ON Студенты TO user1;
      ```
      Этот  запрос  предоставляет  пользователю  `user1`  права  на  чтение  (`SELECT`)  и  вставку  (`INSERT`)  данных  в  таблицу  "Студенты".

    * **`WITH GRANT OPTION`:**  Позволяет  пользователю,  которому  были  предоставлены  права,  передавать  эти  права  другим  пользователям.

2. **`REVOKE`  (Отозвать  права):**

    * **Назначение:**  Отменяет  ранее  предоставленные  привилегии.
    * **Синтаксис:**
      ```sql
      REVOKE <привилегии> ON <объект> FROM <пользователь/роль> [CASCADE | RESTRICT];
      ```
    * **Пример:**
      ```sql
      REVOKE INSERT ON Студенты FROM user1;
      ```
      Этот  запрос  отменяет  у  пользователя  `user1`  право  на  вставку  данных  в  таблицу  "Студенты".

    * **`CASCADE`  (каскадное  удаление):**  Если  указан  `CASCADE`,  то  права  будут  отозваны  и  у  тех  пользователей,  которым  они  были  предоставлены  пользователем,  у  которого  отзывают  права.
    * **`RESTRICT`  (ограничение):**  Если  указан  `RESTRICT`,  то  права  не  будут  отозваны,  если  они  были  предоставлены  другим  пользователям.

**Важно:**

* DCL  —  важная  часть  SQL,  позволяющая  управлять  доступом  к  данным  и  обеспечивать  безопасность  базы  данных.
* Операторы  `GRANT`  и  `REVOKE`  должны  использоваться  с  осторожностью,  так  как  неправильное  их  применение  может  привести  к  нарушению  безопасности  данных.

## 27. Язык SQL. Операторы управления транзакциями.

### Ответ: 

Операторы управления транзакциями (TCL, Transaction Control Language)  в  SQL  обеспечивают  механизм  для  объединения  нескольких  операций  DML  в  единую  логическую  единицу  работы,  называемую  **транзакцией**.  

**Основные операторы TCL:**

1. **`COMMIT`  (Зафиксировать  транзакцию):**

    * **Назначение:**  Завершает  текущую  транзакцию  и  сохраняет  все  изменения,  сделанные  в  ее  рамках,  в  базе  данных.  
    * **Пример:**

      ```sql
      BEGIN TRANSACTION;
      UPDATE Студенты SET Группа = '104' WHERE ID = 1;
      INSERT INTO Оценки (СтудентID, Предмет, Оценка) VALUES (1, 'История', 4);
      COMMIT;
      ```
      В  этом  примере  две  операции  DML  (`UPDATE`  и  `INSERT`)  объединяются  в  одну  транзакцию.  Оператор  `COMMIT`  зафиксирует  обе  операции,  и  изменения  станут  постоянными  в  базе  данных.

2. **`ROLLBACK`  (Откатить  транзакцию):**

    * **Назначение:**  Отменяет  текущую  транзакцию  и  откатывает  все  изменения,  сделанные  с  момента  ее  начала. 
    * **Пример:**

      ```sql
      BEGIN TRANSACTION;
      DELETE FROM Студенты WHERE ID = 1;
      --  Ошибка  в  приложении
      ROLLBACK;
      ```
      В  этом  примере  операция  `DELETE`  будет  отменена  из-за  ошибки  в  приложении.  Оператор  `ROLLBACK`  вернет  базу  данных  к  состоянию  до  начала  транзакции.

3. **`SAVEPOINT`  (Создать  точку  сохранения):**

    * **Назначение:**  Создает  точку  сохранения  внутри  текущей  транзакции.  
    * **Синтаксис:**
      ```sql
      SAVEPOINT <имя_точки_сохранения>;
      ```
    * **Пример:**

      ```sql
      BEGIN TRANSACTION;
      UPDATE Студенты SET Группа = '105' WHERE ID = 2;
      SAVEPOINT Savepoint1;
      DELETE FROM Студенты WHERE ID = 3;
      --  Ошибка  в  приложении
      ROLLBACK TO Savepoint1;
      COMMIT;
      ```
      В  этом  примере  создается  точка  сохранения  `Savepoint1`  после  операции  `UPDATE`.  После  ошибки  в  приложении  транзакция  откатывается  к  точке  `Savepoint1`,  отменяя  только  операцию  `DELETE`,  а  изменения,  сделанные  до  этой  точки,  сохраняются  при  выполнении  `COMMIT`.

**Свойства транзакций (ACID):**

* **Atomicity (Атомарность):**  Транзакция  выполняется  как  единое  целое.  Либо  все  ее  операции  выполняются  успешно,  либо  ни  одна  из  них.
* **Consistency (Согласованность):**  Транзакция  переводит  базу  данных  из  одного  согласованного  состояния  в  другое.
* **Isolation (Изоляция):**  Транзакции  выполняются  изолированно  друг  от  друга,  как  будто  они  выполняются  последовательно.
* **Durability (Долговечность):**  После  успешного  завершения  транзакции  (`COMMIT`)  изменения  становятся  постоянными  и  сохраняются  даже  в  случае  сбоя  системы.

**Важно:**

* Транзакции  являются  важным  механизмом  для  обеспечения  целостности  данных  в  базе  данных.
* Правильное  использование  операторов  TCL  позволяет  гарантировать,  что  данные  в  базе  данных  всегда  будут  находиться  в  согласованном  состоянии.
